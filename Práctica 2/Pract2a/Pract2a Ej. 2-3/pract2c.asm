; Autor: Rubén García de la Fuente
; Grupo 2301
; Práctica 2, ejercicio c

; DEFINICION DEL SEGMENTO DE DATOS
DATOS SEGMENT
    ; DEFINICION DE LOS VECTORES
    vector1 db 1,2,2,4
    vector2 db 4,2,5,1
    vector3 db 3,2,4,1
    errorNumDif DB "FUERA DEL CONJUNTO: 1,2,3,4", 13, 10, '$'
    errorRep DB "REPETICION", 13, 10, '$'
    salidaCorrecta DB "CORRECTO", 13, 10, '$'
DATOS ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE PILA
PILA SEGMENT STACK "STACK"
    DB 40H DUP (0) ;ejemplo de inicialización, 64 bytes inicializados a 0
PILA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO EXTRA
EXTRA SEGMENT
    RESULT DW 0,0 ;ejemplo de inicialización. 2 PALABRAS (4 BYTES)
EXTRA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE CODIGO
CODE SEGMENT
    ASSUME CS: CODE, DS: DATOS, ES: EXTRA, SS: PILA
    ; COMIENZO DEL PROCEDIMIENTO PRINCIPAL
    INICIO PROC
        ; INICIALIZA LOS REGISTROS DE SEGMENTO CON SU VALOR
        MOV AX, DATOS
        MOV DS, AX
        MOV AX, PILA
        MOV SS, AX
        MOV AX, EXTRA
        MOV ES, AX
        MOV SP, 64 ; CARGA EL PUNTERO DE PILA CON EL VALOR MAS ALTO
        ; FIN DE LAS INICIALIZACIONES
        ; COMIENZO DEL PROGRAMA
        CALL COMPROBACION
        ; FIN DEL PROGRAMA
        MOV AX, 4C00H
        INT 21H

    INICIO ENDP
    ;ESPACIO PARA SUBRUTINAS
    COMPROBACION PROC NEAR ; PROCESO QUE COMPRUEBA LA PERTENENCIA Y REPETICION DE NUMEROS EN MATRICES
        MOV SI, 0 ; SI REFERENCIA AL VECTOR DENTRO DE LA MATRIZ (INICIALMENTE A 0)
      BUCLE: ; ESTE ES EL BUCLE PRINCIPAL QUE EJECUTA CADA VECTOR DE LA MATRIZ
        MOV AL, 1 ; AL REFERENCIA A LOS NUMEROS DE REFERENCIA QUE TIENEN QUE ESTAR DENTRO DEL CONJUNTO
        MOV BX, 0 ; BX REFERENCIA A LA POSICION DE CADA VECTOR
        MOV BP, 0 ; BP REFERENCIA LAS POSICIONES ANTERIORES A BX
      NUMDIF: ; COMPROBACION DE PERNENCIA DEL NUMERO AL CONJUNTO
        CMP AL, vector1[SI][BX] ; COMPARAMOS EL NUMERO DE REFERENCIA CON LA POSICION DEL VECTOR
        JNE NEXTAL ; SI NO COINCIDEN PASAMOS A LA SIGUIENTE COMPROBACION DE PERTENENCIA
        CMP BX, 0 ; SI COINCIDEN COMPARAMOS LA POSICION BX CON 0
        JE NEXTBX ; SI COINCIDEN NO PODEMOS REALIZAR LA COMPROBACION DE REPETICIONES Y PASAMOS A LA SIGUIENTE POSICION DEL VECTOR
        JNE NUMREP ; SI NO COINCIDEN REALIZAMOS LA COMPROBACION DE REPETICIONES
      NUMREP: ; COMPROBACION DE REPETICIONES
        MOV AH, vector1[SI][BP]
        CMP AH, vector1[SI][BX] ; COMPARAMOS SI COINCIDEN LOS NUMEROS DADOS (SI HAY REPETICION)
        JNE NEXTBP ; SI NO COINCIDEN PASAMOS A LA SIGUIENTE COMPROBACION DE REPETICION
        JE ERRREP ; SI COINCIDEN ESCRIBIMOS EL ERROR POR PANTALLA
      NEXTAL: ; PASAMOS A LA SIGUIENTE COMPROBACION DE PERTENENCIA
        INC AL
        CMP AL, 5 ; COMPARAMOS EL NUMERO DE REFERENCIA CON EL LIMITE DEL CONJUNTO
        JNE NUMDIF ; SI NO COINCIDEN PASAMOS A LA SIGUIENTE COMPROBACION DE PERTENENCIA
        JE ERRDIF ; SI COINCIDEN IMPRIMIMOS EL ERROR POR PANTALLA
      NEXTBX: ; PASAMOS A LA SIGUIENTE POSICION DEL VECTOR
        MOV AL, 1
        MOV BP, 0
        INC BX
        CMP BX, 4 ; COMPROBAMOS SI HEMOS COMPARADO TODAS LAS POSICIONES DEL VECTOR
        JNE NUMDIF ; SI NO HEMOS COMPARADO TODAS PASAMOS A LA SIGUIENTE POSICION
        JE CORRECTO ; SI HEMOS COMPARADO TODAS IMPRIMIMOS EL MENSAJE DE SALIDA CORRECTA
      NEXTBP: ; PASAMOS A LA SIGUIENTE COMPROBACION DE REPETICION
        INC BP
        CMP BX, BP ; COMPROBAMOS SI BP Y BX SON IGUALES
        JE NEXTBX ; SI LO SON PASAMOS A LA SIGUIENTE POSICION DEL VECTOR
        JMP NUMDIF ; SI NO LO SON REALIZAMOS LA SIGUIENTE COMPROBACION DE PERTENENCIA DEL BP SUCESOR
      CORRECTO: ; IMPRIMIMOS EL MENSAJE DE SALIDA CORRECTA POR PANTALLA
        CALL IMPRESION ; IMPRIMIMOS EL VECTOR CORRESPONDIENTE
        MOV AH, 9
        MOV DX, OFFSET salidaCorrecta
        INT 21H
        JMP FIN ; SALTAMOS AL FIN DEL BUCLE PRINCIPAL
      ERRDIF: ; IMPRIMIMOS EL MENSAJE DE ERROR DE PERNENCIA POR PANTALLA
        CALL IMPRESION ; IMPRIMIMOS EL VECTOR CORRESPONDIENTE
        MOV AH, 9
        MOV DX, OFFSET errorNumDif
        INT 21H
        JMP FIN ; SALTAMOS AL FIN DEL BUCLE PRINCIPAL
      ERRREP: ; IMPRIMIMOS EL MENSAJE DE ERROR DE REPETICION POR PANTALLA
        CALL IMPRESION ; IMPRIMIMOS EL VECTOR CORRESPONDIENTE
        MOV AH, 9
        MOV DX, OFFSET errorRep
        INT 21H
        JMP FIN ; SALTAMOS LA FIN DEL BUCLE PRINCIPAL
      FIN: ; FIN DEL BUCLE PRINCIPAL
        ADD SI, 4
        CMP SI, 4*3 ; COMPROBAMOS SI HEMOS COMPARADO TODOS LOS VECTORES DE LA MATRIZ
        JNE BUCLE ; SI NO HEMOS COMPARADO TODOS PASAMOS AL SIGUIENTE VECTOR
        RET ; SI HEMOS COMPARADO TODOS RETORNAMOS
    COMPROBACION ENDP

    IMPRESION PROC NEAR ; PROCESO QUE IMPRIME UN VECTOR POR PANTALLA
        MOV BP, 0 ; BP HACE REFERENCIA A LA POSICION DEL VECTOR DENTRO DE LA MATRIZ
      BUCLEI:
        MOV AX, 0 ; INICIALIZAMOS AX A 0
        MOV AL, vector1[SI][BP] ; COGEMOS EL NUMERO CORRESPONDIENTE DEL VECTOR Y LO PASAMOS A AL
        CALL CONVERSION ; LLAMAMOS A LA RUTINA CONVERSION
        MOV AH, 9H
        MOV DS, DX
        MOV DX, BX
        INT 21H ; IMPRIMIMOS EL NUMERO CORRESPONDIENTE
        MOV AH, 2H
        MOV DL, ' '
        INT 21H ; IMPIRMIMOS UN ESPACIO
        MOV AX, DATOS
        MOV DS, AX ; ESTABLECEMOS DE NUEVO DS AL SEGMENTO DE DATOS
        INC BP ; INCREMENTAMOS BP
        CMP BP, 4 ; COMPARAMOS BP CON 4
        JNE BUCLEI ; SI NO SON IGUALES PASAMOS A LA SIGUIENTE POSICION DEL VECTOR
        RET ; SI LO SON RETORNAMOS
    IMPRESION ENDP

    CONVERSION PROC NEAR ; PROCESO QUE CONVIERTE UN NUMERO ENTERO EN UNA CADENA DE CARACTERES ASCII EN DECIMAL
        MOV BX, 0 ; BX ES LA POSICION DEL ARRAY DONDE GUARDAMOS EL NUMERO ASCII DECIMAL
        MOV DL, 10 ; DL ES EL DIVISOR DEL NUMERO HEXADECIMAL
      BUCLEC: ; CONVERTIMOS EL NUMERO DE HEXADECIMAL A ASCII DECIMAL (INVERSO)
        DIV DL ; DIVIDIMOS EL NUMERO HEXADECIMAL ENTRE 10
        ADD AH, 30H ; SUMAMOS 30H AL MODULO DE LA DIVISION (EL NUMERO ASCII 0 EMPIEZA EN 30H)
        MOV BYTE PTR RESULT[BX], AH ; ESCRIBIMOS EL NUMERO EN LA POSICION BX DE LA VARAIBLE RESULT
        CMP AL, 0 ; MIRAMOS SI EL COCIENTE ENTERO DE LA DIVISION ES 0
        JE ORDENA1 ; SI ES ASI HEMOS TERMINADO DE DIVIDIR Y PASAMOS AL BUCLE DE ORDENACION
        MOV AH, 0 ; SI NO ES ASI IGUALAMOS EL MODULO DE LA DIVISION A 0
        INC BX ; INCREMENTAMOS BX PARA GUARDAR LA DIVISION EN LA SIGUIENTE POSICION DE MEMORIA
        JNE BUCLEC ; REALIZAMOS LA SIGUIENTE DIVISION
      ORDENA1: ; INICIALIZAMOS EL BUCLE DE ORDENACION
        MOV AX, BX ; MOVEMOS BX A AX PARA REALIZAR LA DIVISION
        MOV DL, 2 ; DL ES EL DIVISOR DE BX
        DIV DL ; DIVIDIMOS AX ENTRE 2 (QUEREMOS SABER LA MITAD DE LA POSICION BX PARA IR INTERCAMBIANDO POSICIONES HASTA LA MITAD)
        MOV AH, BL ; EN AH GUARDAMOS LA ULITMA POSICION DEL ARRAY (LA USAREMOS CUANDO SALGAMOS DEL BUCLE)
        MOV CL, 0 ; CL HACE REFERENCIA A LA POSICION DE INTERCAMBIO (DE IZQUIERDA A DERECHA)
        MOV CH, BL ; CH HACE REFERENCIA A LA POSICION DE INTERCAMBIO (DE DERECHA A IZUQUIERDA)
      ORDENA2: ; ORDENAMOS EL NUMERO ASCII DECIMAL (INVERTIR EL ORDEN)
        MOV BL, CH
        MOV DH, BYTE PTR RESULT[BX] ; EN DH GUARDAMOS EL VALOR DE INTERCAMBIO DE LA POSICION ALTA
        MOV BL, CL
        MOV DL, BYTE PTR RESULT[BX] ; EN DL GUARDAMOS EL VALOR DE INTERCAMBIO DE LA POSICION BAJA
        MOV BYTE PTR RESULT[BX], DH ; PONEMOS EN LA POSICION BAJA EL VALOR DE LA POSICION ALTA
        MOV BL, CH
        MOV BYTE PTR RESULT[BX], DL ; PONEMOS EN LA POSICION ALTA EL VALOR DE LLA POSICION BAJA
        CMP CL, AL ; COMPARAMOS SI CL ES IGUAL A LA MITAD DE LA POSICION MAS ALTA DEL ARRAY
        JE FINC ; ES ES ASI FINALIZAMOS
        INC CL ; SI NO INCREMENTAMOS CL EN UNO
        DEC CH ; DECREMENTAMOS CH EN UNO
        JNE ORDENA2 ; PASAMOS AL SIGUIENTE INTERCAMBIO
      FINC: ; FIN DE LA RUTINA
        MOV BL, AH ; ACTUALIZAMOS BX CON LA ULTIMA POSICION DEL ARRAY
        INC BX ; INCREMENTAMOS EN UNO LA POSICION DEL ARRAY
        MOV RESULT[BX], '$' ; GUARDAMOS EL CARACTER '$' INIDICANDO EL FIN DE LA IMPRESION
        MOV DX, SEG RESULT ; GUARDAMOS EN DX EL SEGMENTO DE RESULT
        MOV BX, OFFSET RESULT ; GUARDAMOS EN BX EL DESPLAZAMIENTO DE RESULT
        RET ; RETORNAMOS
    CONVERSION ENDP
    ; FIN DEL SEGMENTO DE CODIGO
CODE ENDS
; FIN DEL PROGRAMA INDICANDO DONDE COMIENZA LA EJECUCION
END INICIO
